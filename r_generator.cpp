// The following tool generates r_common.cpp and r_common.h

#include "util.h"

struct function {
    u::string type;
    u::string name;
    u::vector<u::string> types;
    u::vector<u::string> names;
};

static u::vector<function> functions;

// The following are OpenGL data types and their actual types and their encoded
// specifier for GL_CHECK
static struct {
    const char *name;
    const char *type;
    const char *format;
    const char *promote; // var args promotion
    char spec;
} types[] = {
    { "GLvoid",     "void",           "",     "",              '0' },
    { "GLchar",     "char",           "%c",   "int",           '1' },
    { "GLenum",     "unsigned int",   "0x%X", "unsigned int",  '2' },
    { "GLboolean",  "unsigned char",  "%c",   "int",           '3' },
    { "GLbitfield", "unsigned int",   "%u",   "unsigned int",  '4' },
    { "GLbyte",     "int8_t",         "%x",   "int",           '5' },
    { "GLshort",    "short",          "%d",   "int",           '6' },
    { "GLint",      "int",            "%d",   "int",           '7' },
    { "GLsizei",    "int",            "%d",   "int",           '8' },
    { "GLubyte",    "uint8_t",        "%X",   "unsigned int",  '9' },
    { "GLushort",   "unsigned short", "%u",   "unsigned int",  'a' },
    { "GLuint",     "unsigned int",   "%u",   "unsigned int",  'b' },
    { "GLfloat",    "float",          "%.2f", "double",        'c' },
    { "GLclampf",   "float",          "%f",   "double",        'd' },
    { "GLintptr",   "intptr_t",       "%p",   "intptr_t",      'e' },
    { "GLsizeiptr", "ssize_t",        "%p",   "intptr_t",      'f' }
};

static void selfCheck(void) {
    // Validate that we're in a consistent state ourselfs, the types table
    // could contain two matching specs for a type which would be wrong
    u::set<char> s;
    for (size_t i = 0; i < sizeof(types)/sizeof(*types); i++) {
        if (s.find(types[i].spec) != s.end()) {
            // Find it again in the thing
            for (size_t j = 0; j < sizeof(types)/sizeof(*types); j++) {
                if (types[j].spec != types[i].spec)
                    continue;
                fprintf(stderr, "spec `%c' already used in `%s'\n",
                    types[i].spec, types[j].name);
                break;
            }
            abort();
        }
        s.insert(types[i].spec);
    }
}

static void genSource(void) {
    size_t largestFunctionName = 0;
    u::unique_ptr<FILE, int(*)(FILE*)> fpe(fopen("r_common.cpp", "w"), &fclose);
    FILE *fp = fpe.get();

    fprintf(fp, "// File automatically generated by r_generator.cpp\n");
    fprintf(fp, "#include <SDL2/SDL.h> // SDL_GL_GetProcAddress\n");
    fprintf(fp, "#include <stdarg.h>\n");
    fprintf(fp, "#define R_COMMON_NO_DEFINES\n");
    fprintf(fp, "#include \"r_common.h\"\n");
    fprintf(fp, "#include \"util.h\"\n\n");
    fprintf(fp, "#ifndef APIENTRY\n");
    fprintf(fp, "#  define APIENTRY\n");
    fprintf(fp, "#endif\n");
    fprintf(fp, "#ifndef APIENTRYP\n");
    fprintf(fp, "#  define APIENTRYP *\n");
    fprintf(fp, "#endif\n\n");
    fprintf(fp, "#ifdef DEBUG_GL\n");
    fprintf(fp, "#   define GL_CHECK_0(...) debugCheck(\"\", __func__, file, line)\n");
    fprintf(fp, "#   define GL_CHECK_1(SPEC, ...) debugCheck(SPEC, __func__, file, line, __VA_ARGS__)\n");
    fprintf(fp, "#else\n");
    fprintf(fp, "#   define GL_CHECK_0(...)\n");
    fprintf(fp, "#   define GL_CHECK_1(...)\n");
    fprintf(fp, "#endif\n\n");

    fprintf(fp, "// Map GL_CHECK to the right thing\n");
    fprintf(fp, "#define PP_PHELP(X, Y) \\\n"
                "   X ## Y\n");
    fprintf(fp, "#define PP_PASTE(X, Y) \\\n"
                "   PP_PHELP(X, Y)\n");
    fprintf(fp, "#define PP_SKIP(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, N, ...) \\\n"
                "   N\n");
    fprintf(fp, "#define PP_SCAN(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) \\\n"
                "   PP_SKIP(, __VA_ARGS__, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12)\n");
    fprintf(fp, "#define PP_COUNT(...) \\\n"
                "   PP_SCAN(12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, __VA_ARGS__)\n");
    fprintf(fp, "#define GL_CHECK_ARG(...) \\\n"
                "   PP_SCAN(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, __VA_ARGS__)\n");
    fprintf(fp, "#define GL_CHECK(...) \\\n"
                "   PP_PASTE(GL_CHECK_, GL_CHECK_ARG(__VA_ARGS__))(__VA_ARGS__)\n\n");

    u::vector<u::string> uppers;
    for (auto &it : functions) {
        // Make an uppercase version for PNFGL
        u::string upper = it.name;
        for (auto &c : upper)
            c = toupper(c);
        uppers.push_back(upper);

        // Generate typedef
        fprintf(fp, "typedef %s (APIENTRYP PFNGL%sPROC)(",
            it.type.c_str(), upper.c_str());

        // Keep track of the largest function name
        if (upper.size() > largestFunctionName)
            largestFunctionName = upper.size();

        // Print off the types only
        for (size_t i = 0; i < it.types.size(); i++) {
            fprintf(fp, "%s", it.types[i].c_str());
            if (i != it.types.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, ");\n");
    }

    fprintf(fp, "\n");
    // Print off the function pointers
    for (size_t i = 0; i < functions.size(); i++) {
        auto &name = functions[i].name;
        fprintf(fp, "static PFNGL%sPROC", uppers[i].c_str());
        auto pad = [&]() {
            size_t pad = largestFunctionName - name.size();
            for (size_t i = 0; i < pad; i++)
                fprintf(fp, " ");
        };
        pad();
        fprintf(fp, " gl%s_", name.c_str());
        pad();
        fprintf(fp, " = nullptr;\n");
    }
    fprintf(fp, "\n");

    fprintf(fp, "namespace gl {\n");

    // Generate the initialization function
    fprintf(fp, "    void init(void) {\n");
    for (size_t i = 0; i < functions.size(); i++) {
        auto &name = functions[i].name;
        fprintf(fp, "        gl%s_", name.c_str());
        size_t pad = largestFunctionName - name.size();
        for (size_t i = 0; i < pad; i++)
            fprintf(fp, " ");
        fprintf(fp, " = (PFNGL%sPROC)SDL_GL_GetProcAddress(\"gl%s\");\n",
            uppers[i].c_str(), name.c_str());

    }
    fprintf(fp, "    }\n");
    fprintf(fp, "\n");

    // Generate the string conversion functions
    fprintf(fp, "// OpenGL debugging\n");
    fprintf(fp, "#ifdef DEBUG_GL\n");
    fprintf(fp, "    template <char C, typename T>\n");
    fprintf(fp, "    u::string stringize(T, char base='?');\n");
    fprintf(fp, "\n");

    // start from 1 to skip GLvoid
    size_t boolean = 0;
    for (size_t i = 1; i < sizeof(types)/sizeof(*types); i++) {
        if (!strcmp(types[i].name, "GLboolean")) {
            boolean = i;
            continue;
        }
        fprintf(fp, "    template <>\n");
        fprintf(fp, "    u::string stringize<'%c', %s>(%s value, char) {\n",
            types[i].spec, types[i].name, types[i].name);
        fprintf(fp, "        return u::format(\"%s=%s\", value);\n",
            types[i].name, types[i].format);
        fprintf(fp, "    }\n");
    }

    // special treatment for booleans
    fprintf(fp, "    template <>\n");
    fprintf(fp, "    u::string stringize<'%c', GLboolean>(GLboolean value, char) {\n",
        types[boolean].spec);
    fprintf(fp, "        return u::format(\"%s=%%s\", value ? \"true\" : \"false\");\n",
        types[boolean].name);
    fprintf(fp, "    }\n");

    // specializations for pointer
    fprintf(fp, "    template <>\n");
    fprintf(fp, "    u::string stringize<'*', void *>(void *value, char base) {\n");
    fprintf(fp, "        if (base == '?')\n");
    fprintf(fp, "            return \"unknown\";\n");
    for (size_t i = 0; i < sizeof(types)/sizeof(*types); i++) {
        // special treatment for strings
        if (!strcmp(types[i].name, "GLchar"))
            continue;
        fprintf(fp, "        else if (base == '%c')\n", types[i].spec);
        fprintf(fp, "            return u::format(\"%s*=%%p\", value);\n", types[i].name);
    }
    fprintf(fp, "        // it's a string\n");
    fprintf(fp, "        return u::format(\"GLchar*=\\\"%%s\\\"\", (const char *)value);\n");
    fprintf(fp, "}\n");

    // Emit the debugCheck code
    fprintf(fp, "\n");
    fprintf(fp, "    static const char *debugErrorString(GLenum error) {\n");
    fprintf(fp, "        switch (error) {\n");
    fprintf(fp, "            case GL_INVALID_ENUM:\n");
    fprintf(fp, "                return \"GL_INVALID_ENUM\";\n");
    fprintf(fp, "                break;\n");
    fprintf(fp, "            case GL_INVALID_VALUE:\n");
    fprintf(fp, "                return \"GL_INVALID_VALUE\";\n");
    fprintf(fp, "                break;\n");
    fprintf(fp, "            case GL_INVALID_FRAMEBUFFER_OPERATION:\n");
    fprintf(fp, "                return \"GL_INVALID_FRAMEBUFFER_OPERATION\";\n");
    fprintf(fp, "                break;\n");
    fprintf(fp, "        }\n");
    fprintf(fp, "        return \"unknown\";\n");
    fprintf(fp, "    }\n");
    fprintf(fp, "    \n");
    fprintf(fp, "    static void debugCheck(const char *spec, const char *function, const char *file, size_t line, ...) {\n");
    fprintf(fp, "        GLenum error = glGetError_();\n");
    fprintf(fp, "        if (error == GL_NO_ERROR)\n");
    fprintf(fp, "            return;\n");
    fprintf(fp, "\n");
    fprintf(fp, "        va_list va;\n");
    fprintf(fp, "        va_start(va, line);\n");
    fprintf(fp, "        u::string contents;\n");
    fprintf(fp, "        for (const char *s = spec; *s; s++) {\n");
    fprintf(fp, "            switch (*s) {\n");
    // 1 to skip GLvoid
    for (size_t i = 1; i < sizeof(types)/sizeof(*types); i++) {
        fprintf(fp, "                case '%c':\n", types[i].spec);
        fprintf(fp, "                    contents += stringize<'%c'>((%s)va_arg(va, %s));\n",
            types[i].spec, types[i].name, types[i].promote);
        fprintf(fp, "                    break;\n");
    }
    // The specialization for pointer types
    fprintf(fp, "                case '*':\n");
    fprintf(fp, "                    contents += stringize<'*'>(va_arg(va, void*), s[1]);\n");
    fprintf(fp, "                    s++; // skip basetype spec\n");
    fprintf(fp, "                    break;\n");
    fprintf(fp, "            }\n");
    fprintf(fp, "            if (s[1])\n");
    fprintf(fp, "                contents += \", \";\n");
    fprintf(fp, "        }\n");
    fprintf(fp, "        va_end(va);\n");
    fprintf(fp, "        \n");
    fprintf(fp, "        fprintf(stderr, \"error: %%s(%%s) (%%s:%%zu) %%s\\n\", function, contents.c_str(),\n"
                "                 file, line, debugErrorString(error));\n");
    fprintf(fp, "    }\n");
    fprintf(fp, "#endif\n");
    fprintf(fp, "\n");

    // Now implement the wrappers
    for (auto &it : functions) {
        fprintf(fp, "    %s %s(", it.type.c_str(), it.name.c_str());
        // Print off types and names
        for (size_t i = 0; i < it.types.size(); i++) {
            fprintf(fp, "%s %s", it.types[i].c_str(), it.names[i].c_str());
            if (i != it.types.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, it.types.size() ? " GL_INFOP" : "GL_INFO");
        fprintf(fp, ") {\n");
        // generate the call (names only)
        if (it.type == "void")
            fprintf(fp, "        gl%s_(", it.name.c_str());
        else
            fprintf(fp, "        %s result = gl%s_(",
                it.type.c_str(), it.name.c_str());
        for (size_t i = 0; i < it.names.size(); i++) {
            fprintf(fp, "%s", it.names[i].c_str());
            if (i != it.types.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, ");\n");
        // generate the check hook"
        fprintf(fp, "        GL_CHECK(");
        if (it.types.size()) {
            fprintf(fp, "\"");
            // Generate the spec string
            bool found;
            for (auto &jt : it.types) {
                found = false;
                for (size_t i = 0; i < sizeof(types)/sizeof(*types); i++) {
                    // Standard check
                    if (jt != types[i].name) {
                        // Trim leading "const "
                        u::string copy = jt;
                        size_t find = copy.find("const ");
                        if (find != u::string::npos)
                            copy.erase(find, 6);
                        if (copy != types[i].name) {
                            // Check Must be a pointer type
                            if (copy.find("*") != u::string::npos) {
                                fprintf(fp, "*");
                                // Figure out basetype now of the pointer
                                size_t levels = 0;
                                while (copy.find('*') != u::string::npos) {
                                    copy.erase(copy.find('*'), 1);
                                    levels++;
                                }
                                // treat it as GLvoid when more than one *
                                if (levels != 1)
                                    copy = "GLvoid";
                                bool base = false;
                                for (size_t j = 0; j < sizeof(types)/sizeof(*types); j++) {
                                    if (copy != types[j].name)
                                        continue;
                                    fprintf(fp, "%c", types[j].spec);
                                    base = true;
                                    break;
                                }
                                if (!base)
                                    printf("couldn't find base spec for `%s' in `%s'\n",
                                        copy.c_str(), it.name.c_str());
                                found = true;
                                break;
                            }
                        }
                    } else {
                        fprintf(fp, "%c", types[i].spec);
                        found = true;
                        break;
                    }
                }
                if (!found)
                    printf("couldn't find spec for `%s' in `%s'\n", jt.c_str(), it.name.c_str());
            }
            fprintf(fp, "\", ");
            // Pass in the arguments for it now
            for (size_t i = 0; i < it.names.size(); i++) {
                fprintf(fp, "%s", it.names[i].c_str());
                if (i != it.types.size() - 1)
                    fprintf(fp, ", ");
            }
        }
        fprintf(fp, ");\n");
        if (it.type != "void")
            fprintf(fp, "        return result;\n");
        fprintf(fp, "    }\n");
        fprintf(fp, "\n");
    }
    fprintf(fp, "}\n");
}

static void genHeader(void) {
    size_t largestFunctionName = 0;
    u::unique_ptr<FILE, int(*)(FILE*)> fpe(fopen("r_common.h", "w"), &fclose);
    FILE *fp = fpe.get();
    fprintf(fp, "// file automatically generated by r_generator.cpp\n");
    fprintf(fp, "#ifndef R_COMMON_HDR\n");
    fprintf(fp, "#define R_COMMON_HDR\n");
    fprintf(fp, "#include <SDL2/SDL_opengl.h>\n");
    fprintf(fp, "#include <stdint.h>\n\n");
    fprintf(fp, "#ifdef DEBUG_GL\n");
    fprintf(fp, "#   define GL_INFO const char *file, size_t line\n");
    fprintf(fp, "#   define GL_INFOP , GL_INFO\n");
    fprintf(fp, "#else\n");
    fprintf(fp, "#   define GL_INFO\n");
    fprintf(fp, "#   define GL_INFOP\n");
    fprintf(fp, "#endif\n\n");
    fprintf(fp, "namespace gl {\n");

    // Emit the init function
    fprintf(fp, "    void init(void);\n");

    // Now the rest
    for (auto &it : functions) {
        fprintf(fp, "    %s %s(", it.type.c_str(), it.name.c_str());
        // Print off types and names
        if (it.name.size() > largestFunctionName)
            largestFunctionName = it.name.size();
        for (size_t i = 0; i < it.types.size(); i++) {
            fprintf(fp, "%s %s", it.types[i].c_str(), it.names[i].c_str());
            if (i != it.types.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, it.types.size() ? " GL_INFOP" : "GL_INFO");
        fprintf(fp, ");\n");
    }

    fprintf(fp, "}\n");
    fprintf(fp, "\n");

    // Print off the macros which wrap it
    fprintf(fp, "#if defined(DEBUG_GL) && !defined(R_COMMON_NO_DEFINES)\n");
    for (auto &it : functions) {
        fprintf(fp, "#   define %s(...)", it.name.c_str());
        const size_t length = largestFunctionName - it.name.size();
        for (size_t i = 0; i < length; i++)
            fprintf(fp, " ");
        if (it.names.size() != 0)
            fprintf(fp, " %s(__VA_ARGS__, __FILE__, __LINE__)\n", it.name.c_str());
        else
            fprintf(fp, " %s(/* no arg */ __FILE__, __LINE__)\n", it.name.c_str());
    }
    fprintf(fp, "#endif\n");
    fprintf(fp, "#endif\n");
}

int main(void) {
    selfCheck();
    u::unique_ptr<FILE, int(*)(FILE*)> fp(fopen("r_gl", "r"), &fclose);
    while (auto getline = u::getline(fp.get())) {
        u::string line = *getline;
        char *cursor = &line[0];
        char *stop;

        auto skipSpaces = [&]() {
            while (isspace(*cursor))
                cursor++;
        };

        // Parse functions
        function f;

        skipSpaces();
        if (!(stop = strchr(cursor, ':'))) {
            fprintf(stderr, "expected `:'\n");
            return 1;
        }
        f.type = u::string(cursor, stop - cursor);
        cursor = stop + 1;

        skipSpaces();
        if (!(stop = strchr(cursor, '('))) {
            fprintf(stderr, "expected `('\n");
            return 1;
        }
        f.name = u::string(cursor, stop - cursor);
        cursor = stop + 1;

        // Parse formals for function
        for (;;) {
            stop = strchr(cursor, ':');
            if (!stop) break;
            f.types.emplace_back(cursor, stop - cursor);
            cursor = stop + 1;
            skipSpaces();
            if ((stop = strchr(cursor, ','))) {
                f.names.emplace_back(cursor, stop - cursor);
                cursor = stop + 1;
                skipSpaces();
            } else {
                if (!(stop = strchr(cursor, ')'))) {
                    fprintf(stderr, "expected `)'\n");
                    exit(1);
                }
                f.names.emplace_back(cursor, stop - cursor);
                break;
            }
        }
        functions.push_back(f);
    }
    genHeader();
    genSource();
}
